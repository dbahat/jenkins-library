package malwarescan

import (
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"strings"
	"time"

	piperhttp "github.com/SAP/jenkins-library/pkg/http"
	"github.com/pkg/errors"
	"github.com/sirupsen/logrus"
)

// ScanResult : Returned by the scan endpoint of the malwarescan api of SAP CP
type ScanResult struct {
	MalwareDetected          bool   `json:"malwareDetected"`
	EncryptedContentDetected bool   `json:"encryptedContentDetected"`
	ScanSize                 int    `json:"scanSize"`
	Finding                  string `json:"finding,omitempty"`
	MimeType                 string `json:"mimeType"`
	SHA256                   string `json:"SHA256"`
}

type AsyncUploadResult struct {
	JobID string `json:"jobID"`
}

type AsyncStatus string

const (
	STATE_PROCESSING AsyncStatus = "processing"
	STATE_DONE       AsyncStatus = "done"
	STATE_ERROR      AsyncStatus = "error"
)

type AsyncIncident struct {
	Message  string `json:"message"`
	FilePath string `json:"filePath"`
}

type AsyncScanResult struct {
	Created       time.Time       `json:"created"`
	Errors        []AsyncIncident `json:"errors"`
	Findings      []AsyncIncident `json:"findings"`
	Encrypted     []AsyncIncident `json:"encryptedContent"`
	Processed     int             `json:"processed"`
	FileCount     int             `json:"fileCount"`
	Sha256        string          `json:"sha256"`
	SizeByte      int             `json:"sizeByte"`
	Status        AsyncStatus     `json:"status"`
	Updated       time.Time       `json:"updated"`
	CorrelationID string          `json:"correlation_id"`
}

// Info : Returned by the info endpoint of the malwarescan api of SAP CP
type Info struct {
	MaxScanSize        int
	SignatureTimestamp string
	EngineVersion      string
}

// ScanError : Returned by the malwarescan api of SAP CP in case of an error
type ScanError struct {
	Message string
}

// Client : Interface for the malwarescan api provided by SAP CP (see https://api.sap.com/api/MalwareScanAPI/overview)
type Client interface {
	ScanAsync(candidate io.Reader) (*ScanResult, error)
	Scan(candidate io.Reader) (*ScanResult, error)
	Info() (*Info, error)
}

// ClientImpl : Client implementation of the malwarescan api provided by SAP CP (see https://api.sap.com/api/MalwareScanAPI/overview)
type ClientImpl struct {
	HTTPClient   piperhttp.Sender
	Host         string
	Timeout      time.Duration
	PollInterval time.Duration
	Logger       *logrus.Entry
}

// ScanAsync : Triggers an asynchronous malwarescan in SAP CP for the given content.
func (c *ClientImpl) ScanAsync(candidate io.Reader) (*ScanResult, error) {
	var scanResult ScanResult
	var asyncUploadResult AsyncUploadResult

	headers := http.Header{}
	headers.Add("Content-Type", "application/octet-stream")

	err := c.sendAPIRequest("POST", "/v2/tar", candidate, headers, &asyncUploadResult)
	if err != nil {
		return nil, err
	}

	if len(asyncUploadResult.JobID) != 0 {
		scanResult, err = c.pollResult(asyncUploadResult.JobID)
		if err != nil {
			return nil, err
		}

	} else {
		return nil, fmt.Errorf("Malware asynchronous scan upload failed, missing job id.")
	}

	return &scanResult, nil
}

// pollResult polls the malwarescan for the result scan
func (c *ClientImpl) pollResult(jobID string) (ScanResult, error) {
	var scanResult ScanResult
	var asyncScanResult AsyncScanResult
	var err error
	pollInterval := 10 * time.Second

	if c.PollInterval > 0 {
		pollInterval = c.PollInterval
	}

	timeout := time.NewTimer(c.Timeout)
	ticker := time.NewTicker(pollInterval)
	defer ticker.Stop()

	for {
		select {
		case <-timeout.C:
			err = fmt.Errorf("Time out checking job status.")
			return scanResult, err

		case <-ticker.C:
			// first call will not be trigger before first tick (10s)
			c.Logger.Debugf("Checking status for jobID %v", jobID)
			err = c.sendAPIRequest(http.MethodGet, fmt.Sprintf("/v2/status?id=%v", jobID), nil, nil, &asyncScanResult)
			if err != nil {
				return scanResult, err
			}

			if asyncScanResult.Status == STATE_ERROR {
				errmsg := []string{}
				for _, incident := range asyncScanResult.Errors {
					errmsg = append(errmsg, incident.Message)
				}
				return scanResult, fmt.Errorf("Error while scanning:\n%s", strings.Join(errmsg, "\n"))

			} else if asyncScanResult.Status == STATE_DONE {
				findings := append(asyncScanResult.Findings, asyncScanResult.Encrypted...)
				scanResult.MalwareDetected = len(asyncScanResult.Findings) > 0
				scanResult.EncryptedContentDetected = len(asyncScanResult.Encrypted) > 0
				scanResult.ScanSize = asyncScanResult.SizeByte
				scanResult.Finding = fmt.Sprintf("%+v", findings)
				scanResult.MimeType = "application/x-tar"
				scanResult.SHA256 = asyncScanResult.Sha256
				return scanResult, nil
			}
		}
	}
}

// Scan : Triggers a malwarescan in SAP CP for the given content.
func (c *ClientImpl) Scan(candidate io.Reader) (*ScanResult, error) {
	var scanResult ScanResult

	headers := http.Header{}
	headers.Add("Content-Type", "application/octet-stream")

	err := c.sendAPIRequest("POST", "/scan", candidate, headers, &scanResult)

	if err != nil {
		return nil, err
	}

	return &scanResult, nil
}

// Info : Returns some information about the scanengine used by the malwarescan service.
func (c *ClientImpl) Info() (*Info, error) {
	var info Info

	err := c.sendAPIRequest("GET", "/info", nil, nil, &info)

	if err != nil {
		return nil, err
	}

	return &info, nil
}

func (c *ClientImpl) sendAPIRequest(method, endpoint string, body io.Reader, header http.Header, obj interface{}) error {
	// piper http utils mashall some http response codes into errors. We wan't to check the status code
	// ourselves hence we wait with returning that error (maybe also related to errors others than http status codes)

	// sendRequest results in any combination of nil and non-nil response and error.
	// a response body could even be already closed.
	response, err := c.HTTPClient.SendRequest(method, c.Host+endpoint, body, header, nil)

	if response.StatusCode != 200 && response.StatusCode != 201 {
		var scanError ScanError

		err = c.unmarshalResponse(response, &scanError)

		if err != nil {
			return fmt.Errorf("MalwareService returned with status code %d, no further information available", response.StatusCode)
		}

		return fmt.Errorf("MalwareService returned with status code %d: %s", response.StatusCode, scanError.Message)
	}

	return c.unmarshalResponse(response, obj)
}

func (c *ClientImpl) readBody(response *http.Response) ([]byte, error) {
	if response != nil && response.Body != nil {
		defer response.Body.Close()
		return ioutil.ReadAll(response.Body)
	}

	return nil, fmt.Errorf("No response body available")
}

func (c *ClientImpl) unmarshalResponse(response *http.Response, obj interface{}) error {
	body, err := c.readBody(response)

	if err != nil {
		return err
	}

	err = json.Unmarshal(body, obj)

	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("Unmarshalling of response body failed. Body: '%s'", body))
	}

	return err
}
